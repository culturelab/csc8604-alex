using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading.Tasks;
using Windows.Devices.Enumeration;
using Windows.Devices.I2c;
using Windows.Devices.Spi;
using Windows.Storage.Streams;

namespace AlexTheAdventurous
{
    // This class is needed to inject SPI camera into the process until the standard USB cameras become supported.
    // The camera is ArduCAM MINI with OV2640 sensor (http://www.arducam.com/arducam-mini-released/) which does not come with any software documentation.
    // The code below is mainly port of the official library at https://github.com/ArduCAM.

    internal static class Camera
    {
        private class ProgramMemory : List<Tuple<byte, byte>>
        {
            public void Add(byte register, byte value)
            {
                Add(Tuple.Create(register, value));
            }
        }

        static readonly ProgramMemory OV2640_JPEG_INIT = new ProgramMemory
        {
            { 0xff, 0x00 }, { 0x2c, 0xff }, { 0x2e, 0xdf }, { 0xff, 0x01 }, { 0x3c, 0x32 }, { 0x11, 0x04 }, { 0x09, 0x02 }, { 0x04, 0x28 }, { 0x13, 0xe5 }, { 0x14, 0x48 }, { 0x2c, 0x0c },
            { 0x33, 0x78 }, { 0x3a, 0x33 }, { 0x3b, 0xfB }, { 0x3e, 0x00 }, { 0x43, 0x11 }, { 0x16, 0x10 }, { 0x39, 0x92 }, { 0x35, 0xda }, { 0x22, 0x1a }, { 0x37, 0xc3 }, { 0x23, 0x00 },
            { 0x34, 0xc0 }, { 0x36, 0x1a }, { 0x06, 0x88 }, { 0x07, 0xc0 }, { 0x0d, 0x87 }, { 0x0e, 0x41 }, { 0x4c, 0x00 }, { 0x48, 0x00 }, { 0x5B, 0x00 }, { 0x42, 0x03 }, { 0x4a, 0x81 },
            { 0x21, 0x99 }, { 0x24, 0x40 }, { 0x25, 0x38 }, { 0x26, 0x82 }, { 0x5c, 0x00 }, { 0x63, 0x00 }, { 0x61, 0x70 }, { 0x62, 0x80 }, { 0x7c, 0x05 }, { 0x20, 0x80 }, { 0x28, 0x30 },
            { 0x6c, 0x00 }, { 0x6d, 0x80 }, { 0x6e, 0x00 }, { 0x70, 0x02 }, { 0x71, 0x94 }, { 0x73, 0xc1 }, { 0x12, 0x40 }, { 0x17, 0x11 }, { 0x18, 0x43 }, { 0x19, 0x00 }, { 0x1a, 0x4b },
            { 0x32, 0x09 }, { 0x37, 0xc0 }, { 0x4f, 0x60 }, { 0x50, 0xa8 }, { 0x6d, 0x00 }, { 0x3d, 0x38 }, { 0x46, 0x3f }, { 0x4f, 0x60 }, { 0x0c, 0x3c }, { 0xff, 0x00 }, { 0xe5, 0x7f },
            { 0xf9, 0xc0 }, { 0x41, 0x24 }, { 0xe0, 0x14 }, { 0x76, 0xff }, { 0x33, 0xa0 }, { 0x42, 0x20 }, { 0x43, 0x18 }, { 0x4c, 0x00 }, { 0x87, 0xd5 }, { 0x88, 0x3f }, { 0xd7, 0x03 },
            { 0xd9, 0x10 }, { 0xd3, 0x82 }, { 0xc8, 0x08 }, { 0xc9, 0x80 }, { 0x7c, 0x00 }, { 0x7d, 0x00 }, { 0x7c, 0x03 }, { 0x7d, 0x48 }, { 0x7d, 0x48 }, { 0x7c, 0x08 }, { 0x7d, 0x20 },
            { 0x7d, 0x10 }, { 0x7d, 0x0e }, { 0x90, 0x00 }, { 0x91, 0x0e }, { 0x91, 0x1a }, { 0x91, 0x31 }, { 0x91, 0x5a }, { 0x91, 0x69 }, { 0x91, 0x75 }, { 0x91, 0x7e }, { 0x91, 0x88 },
            { 0x91, 0x8f }, { 0x91, 0x96 }, { 0x91, 0xa3 }, { 0x91, 0xaf }, { 0x91, 0xc4 }, { 0x91, 0xd7 }, { 0x91, 0xe8 }, { 0x91, 0x20 }, { 0x92, 0x00 }, { 0x93, 0x06 }, { 0x93, 0xe3 },
            { 0x93, 0x05 }, { 0x93, 0x05 }, { 0x93, 0x00 }, { 0x93, 0x04 }, { 0x93, 0x00 }, { 0x93, 0x00 }, { 0x93, 0x00 }, { 0x93, 0x00 }, { 0x93, 0x00 }, { 0x93, 0x00 }, { 0x93, 0x00 },
            { 0x96, 0x00 }, { 0x97, 0x08 }, { 0x97, 0x19 }, { 0x97, 0x02 }, { 0x97, 0x0c }, { 0x97, 0x24 }, { 0x97, 0x30 }, { 0x97, 0x28 }, { 0x97, 0x26 }, { 0x97, 0x02 }, { 0x97, 0x98 },
            { 0x97, 0x80 }, { 0x97, 0x00 }, { 0x97, 0x00 }, { 0xc3, 0xed }, { 0xa4, 0x00 }, { 0xa8, 0x00 }, { 0xc5, 0x11 }, { 0xc6, 0x51 }, { 0xbf, 0x80 }, { 0xc7, 0x10 }, { 0xb6, 0x66 },
            { 0xb8, 0xA5 }, { 0xb7, 0x64 }, { 0xb9, 0x7C }, { 0xb3, 0xaf }, { 0xb4, 0x97 }, { 0xb5, 0xFF }, { 0xb0, 0xC5 }, { 0xb1, 0x94 }, { 0xb2, 0x0f }, { 0xc4, 0x5c }, { 0xc0, 0x64 },
            { 0xc1, 0x4B }, { 0x8c, 0x00 }, { 0x86, 0x3D }, { 0x50, 0x00 }, { 0x51, 0xC8 }, { 0x52, 0x96 }, { 0x53, 0x00 }, { 0x54, 0x00 }, { 0x55, 0x00 }, { 0x5a, 0xC8 }, { 0x5b, 0x96 },
            { 0x5c, 0x00 }, { 0xd3, 0x00 }, { 0xc3, 0xed }, { 0x7f, 0x00 }, { 0xda, 0x00 }, { 0xe5, 0x1f }, { 0xe1, 0x67 }, { 0xe0, 0x00 }, { 0xdd, 0x7f }, { 0x05, 0x00 },
            { 0x12, 0x40 }, { 0xd3, 0x04 }, { 0xc0, 0x16 }, { 0xC1, 0x12 }, { 0x8c, 0x00 }, { 0x86, 0x3d }, { 0x50, 0x00 }, { 0x51, 0x2C }, { 0x52, 0x24 }, { 0x53, 0x00 }, { 0x54, 0x00 },
            { 0x55, 0x00 }, { 0x5A, 0x2c }, { 0x5b, 0x24 }, { 0x5c, 0x00 }, { 0xff, 0xff },
        };

        static readonly ProgramMemory OV2640_YUV422 = new ProgramMemory
        {
            { 0xFF, 0x00 }, { 0x05, 0x00 }, { 0xDA, 0x10 }, { 0xD7, 0x03 }, { 0xDF, 0x00 }, { 0x33, 0x80 }, { 0x3C, 0x40 }, { 0xe1, 0x77 }, { 0x00, 0x00 }, { 0xff, 0xff },
        };

        static readonly ProgramMemory OV2640_JPEG = new ProgramMemory
        {
            { 0xe0, 0x14 }, { 0xe1, 0x77 }, { 0xe5, 0x1f }, { 0xd7, 0x03 }, { 0xda, 0x10 }, { 0xe0, 0x00 }, { 0xFF, 0x01 }, { 0x04, 0x08 }, { 0xff, 0xff }
        };

        static readonly ProgramMemory OV2640_640x480_JPEG = new ProgramMemory
        {
            { 0xff, 0x01 }, { 0x11, 0x01 }, { 0x12, 0x00 }, { 0x17, 0x11 }, { 0x18, 0x75 }, { 0x32, 0x36 }, { 0x19, 0x01 }, { 0x1a, 0x97 }, { 0x03, 0x0f }, { 0x37, 0x40 },
            { 0x4f, 0xbb }, { 0x50, 0x9c }, { 0x5a, 0x57 }, { 0x6d, 0x80 }, { 0x3d, 0x34 }, { 0x39, 0x02 }, { 0x35, 0x88 }, { 0x22, 0x0a }, { 0x37, 0x40 }, { 0x34, 0xa0 },
            { 0x06, 0x02 }, { 0x0d, 0xb7 }, { 0x0e, 0x01 },
            { 0xff, 0x00 }, { 0xe0, 0x04 }, { 0xc0, 0xc8 }, { 0xc1, 0x96 }, { 0x86, 0x3d }, { 0x50, 0x89 }, { 0x51, 0x90 }, { 0x52, 0x2c }, { 0x53, 0x00 }, { 0x54, 0x00 }, 
            { 0x55, 0x88 }, { 0x57, 0x00 }, { 0x5a, 0xa0 }, { 0x5b, 0x78 }, { 0x5c, 0x00 }, { 0xd3, 0x04 }, { 0xe0, 0x00 }, 
            { 0xff, 0xff },
        };

        static readonly ProgramMemory OV2640_160x120_JPEG = new ProgramMemory
        { 
            { 0xff, 0x01 }, { 0x12, 0x40 }, { 0x17, 0x11 }, { 0x18, 0x43 }, { 0x19, 0x00 }, { 0x1a, 0x4b }, { 0x32, 0x09 }, { 0x4f, 0xca }, { 0x50, 0xa8 }, { 0x5a, 0x23 }, 
            { 0x6d, 0x00 }, { 0x39, 0x12 }, { 0x35, 0xda }, { 0x22, 0x1a }, { 0x37, 0xc3 }, { 0x23, 0x00 }, { 0x34, 0xc0 }, { 0x36, 0x1a }, { 0x06, 0x88 }, { 0x07, 0xc0 }, 
            { 0x0d, 0x87 }, { 0x0e, 0x41 }, { 0x4c, 0x00 }, { 0xff, 0x00 }, { 0xe0, 0x04 }, { 0xc0, 0x64 }, { 0xc1, 0x4b }, { 0x86, 0x35 }, { 0x50, 0x92 }, { 0x51, 0xc8 }, 
            { 0x52, 0x96 }, { 0x53, 0x00 }, { 0x54, 0x00 }, { 0x55, 0x00 }, { 0x57, 0x00 }, { 0x5a, 0x28 }, { 0x5b, 0x1e }, { 0x5c, 0x00 }, { 0xe0, 0x00 }, { 0xff, 0xff },
        };

        static readonly ProgramMemory OV2640_320x240_JPEG = new ProgramMemory
        { 
            { 0xff, 0x01 }, { 0x12, 0x40 }, { 0x17, 0x11 }, { 0x18, 0x43 }, { 0x19, 0x00 }, { 0x1a, 0x4b }, { 0x32, 0x09 }, { 0x4f, 0xca }, { 0x50, 0xa8 }, { 0x5a, 0x23 }, 
            { 0x6d, 0x00 }, { 0x39, 0x12 }, { 0x35, 0xda }, { 0x22, 0x1a }, { 0x37, 0xc3 }, { 0x23, 0x00 }, { 0x34, 0xc0 }, { 0x36, 0x1a }, { 0x06, 0x88 }, { 0x07, 0xc0 }, 
            { 0x0d, 0x87 }, { 0x0e, 0x41 }, { 0x4c, 0x00 }, { 0xff, 0x00 }, { 0xe0, 0x04 }, { 0xc0, 0x64 }, { 0xc1, 0x4b }, { 0x86, 0x35 }, { 0x50, 0x89 }, { 0x51, 0xc8 }, 
            { 0x52, 0x96 }, { 0x53, 0x00 }, { 0x54, 0x00 }, { 0x55, 0x00 }, { 0x57, 0x00 }, { 0x5a, 0x50 }, { 0x5b, 0x3c }, { 0x5c, 0x00 }, { 0xe0, 0x00 }, { 0xff, 0xff },
        };

        static readonly ProgramMemory OV2640_352x288_JPEG = new ProgramMemory
        {
            { 0xff, 0x01 }, { 0x12, 0x40 }, { 0x17, 0x11 }, { 0x18, 0x43 }, { 0x19, 0x00 }, { 0x1a, 0x4b }, { 0x32, 0x09 }, { 0x4f, 0xca }, { 0x50, 0xa8 }, { 0x5a, 0x23 }, 
            { 0x6d, 0x00 }, { 0x39, 0x12 }, { 0x35, 0xda }, { 0x22, 0x1a }, { 0x37, 0xc3 }, { 0x23, 0x00 }, { 0x34, 0xc0 }, { 0x36, 0x1a }, { 0x06, 0x88 }, { 0x07, 0xc0 }, 
            { 0x0d, 0x87 }, { 0x0e, 0x41 }, { 0x4c, 0x00 }, { 0xff, 0x00 }, { 0xe0, 0x04 }, { 0xc0, 0x64 }, { 0xc1, 0x4b }, { 0x86, 0x35 }, { 0x50, 0x89 }, { 0x51, 0xc8 }, 
            { 0x52, 0x96 }, { 0x53, 0x00 }, { 0x54, 0x00 }, { 0x55, 0x00 }, { 0x57, 0x00 }, { 0x5a, 0x58 }, { 0x5b, 0x48 }, { 0x5c, 0x00 }, { 0xe0, 0x00 }, { 0xff, 0xff }, 
        }; 

        private const byte ARDUCHIP_TEST1 = 0x00;
        private const byte ARDUCHIP_MODE = 0x02;
        private const byte ARDUCHIP_FIFO = 0x04;
        private const byte ARDUCHIP_TRIG = 0x41;
        private const byte FIFO_CLEAR_MASK = 0x01;
        private const byte FIFO_START_MASK = 0x02;
        private const byte CAP_DONE_MASK = 0x08;

        private const byte OV2640_CHIPID_HIGH = 0x0A;
        private const byte OV2640_CHIPID_LOW = 0x0B;

        private const byte SensorAddress = 0x30;

        private static SpiDevice Chip;
        private static I2cDevice Sensor;

        private static bool _cameraAvailable;
        private static bool IsCameraAvailable
        {
            get { return _cameraAvailable; }
        }

        public static async Task Initialize()
        {
            if (await InitializeSpi() && await InitializeI2c())
            {
                _cameraAvailable = true;

                WriteChipRegister(ARDUCHIP_MODE, 0x00);
                await InitializeJpeg();
            }
        }

        private static async Task<bool> InitializeSpi()
        {
            string spiAqs = SpiDevice.GetDeviceSelector("SPI0");
            DeviceInformationCollection devicesInfo = await DeviceInformation.FindAllAsync(spiAqs);

            if (devicesInfo.Count < 1)
                return false;

            SpiConnectionSettings settings = new SpiConnectionSettings(0);
            settings.ClockFrequency = 8000000;

            Chip = await SpiDevice.FromIdAsync(devicesInfo[0].Id, settings);

            WriteChipRegister(ARDUCHIP_TEST1, 0x55);
            if (ReadChipRegister(ARDUCHIP_TEST1) == 0x55)
            {
                Debug.WriteLine("Camera SPI bus working.");
                return true;
            }
            else
            {
                Debug.WriteLine("Camera SPI bus failed.");
                return false;
            }
        }

        private static async Task<bool> InitializeI2c()
        {
            string i2cAqs = I2cDevice.GetDeviceSelector("I2C1");
            DeviceInformationCollection devicesInfo = await DeviceInformation.FindAllAsync(i2cAqs);

            if (devicesInfo.Count < 1)
                return false;

            I2cConnectionSettings settings = new I2cConnectionSettings(0x30);
            Sensor = await I2cDevice.FromIdAsync(devicesInfo[0].Id, settings);

            byte vid = ReadSensorRegister(OV2640_CHIPID_HIGH);
            byte pid = ReadSensorRegister(OV2640_CHIPID_LOW);

            if (vid == 0x26 && pid == 0x42)
            {
                Debug.WriteLine("Camera I2C bus working.");
                return true;
            }
            else
            {
                Debug.WriteLine("Camera I2C bus failed.");
                return false;
            }
        }

        private static async Task InitializeJpeg()
        {
            WriteSensorRegister(0xff, 0x01);
            WriteSensorRegister(0x12, 0x80);

            await Task.Delay(100);
            WriteSensorRegisters(OV2640_JPEG_INIT);
            WriteSensorRegisters(OV2640_YUV422);
            WriteSensorRegisters(OV2640_JPEG);
            WriteSensorRegister(0xff, 0x01);
            WriteSensorRegister(0x15, 0x00);
            WriteSensorRegisters(OV2640_160x120_JPEG);
        }

        private static byte[] Buffer2 = new byte[2];
        private static byte ReadChipRegister(byte register)
        {
            Buffer2[0] = register;
            Buffer2[1] = 0x00;

            Chip.TransferFullDuplex(Buffer2, Buffer2);
            return Buffer2[1];
        }
        private static void WriteChipRegister(byte register, byte value)
        {
            Buffer2[0] = (byte)(register | 0x80);
            Buffer2[1] = value;

            Chip.Write(Buffer2);
        }

        private static byte[] Buffer1 = new byte[1];
        private static void WriteSensorRegister(byte register, byte value)
        {
            Buffer2[0] = register;
            Buffer2[1] = value;

            Sensor.Write(Buffer2);
        }
        private static void WriteSensorRegisters(ProgramMemory program)
        {
            foreach (Tuple<byte, byte> pair in program)
                WriteSensorRegister(pair.Item1, pair.Item2);
        }
        private static byte ReadSensorRegister(byte register)
        {
            Buffer1[0] = register;

            Sensor.WriteRead(Buffer1, Buffer1);
            return Buffer1[0];
        }

        public static async Task<InMemoryRandomAccessStream> TakePicture()
        {
            Touch.DisableTouch();
            Debug.WriteLine("Taking picture...");

            InMemoryRandomAccessStream stream = new InMemoryRandomAccessStream();
            try
            {
                WriteChipRegister(ARDUCHIP_FIFO, FIFO_CLEAR_MASK);
                WriteChipRegister(ARDUCHIP_FIFO, FIFO_START_MASK);

                while ((ReadChipRegister(ARDUCHIP_TRIG) & CAP_DONE_MASK) == 0)
                    await Task.Delay(100);

                Debug.WriteLine("Receiving picture...");
                using (DataWriter writer = new DataWriter(stream))
                {
                    byte data = ReadChipRegister(0x3D);
                    byte lastData = 0;

                    while (data != 0xD9 || lastData != 0xFF)
                    {
                        lastData = data;
                        writer.WriteByte(lastData);
                        data = ReadChipRegister(0x3D);
                    }

                    WriteChipRegister(ARDUCHIP_FIFO, FIFO_CLEAR_MASK);
                    await writer.StoreAsync();
                    writer.DetachStream();
                }
            }
            finally
            {
                Touch.EnableTouch();
            }

            Debug.WriteLine($"Received {stream.Position} bytes.");
            return stream;
        }
    }
}
